
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Dados Unicode no Django &mdash; Django v1.3.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Django v1.3.1 documentation" href="../index.html" />
    <link rel="up" title="Referência da API" href="index.html" />
    <link rel="next" title="Django Utils" href="utils.html" />
    <link rel="prev" title="A linguagem de template do Django: Para programadores Python" href="templates/api.html" />
 
<script type="text/javascript" src="../templatebuiltins.js"></script>
<script type="text/javascript">
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);
</script>

  </head>
  <body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django v1.3.1 documentation</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Tabela de conteúdos" href="../contents.html">Tabela de conteúdos</a>  |
        <a title="Índice Global" href="../genindex.html">Índice</a>  |
        <a title="Busca" href="../py-modindex.html">Módulos</a>
      </div>
      <div class="nav">
    &laquo; <a href="templates/api.html" title="A linguagem de template do Django: Para programadores Python">previous</a> 
     |
    <a href="index.html" title="Referência da API" accesskey="U">up</a>
   |
    <a href="utils.html" title="Django Utils">next</a> &raquo;</div>
    </div>
    
    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="ref-unicode">
            
  <div class="section" id="s-dados-unicode-no-django">
<span id="dados-unicode-no-django"></span><h1>Dados Unicode no Django<a class="headerlink" href="#dados-unicode-no-django" title="Permalink to this headline">¶</a></h1>
<div class="versionadded">
<span class="title">New in Django 1.0:</span> <a class="reference internal" href="../releases/1.0.html"><em>Please, see the release notes</em></a></div>
<p>O Django nativamente suporta dados Unicode por toda parte. Proporcionando ao seu
banco de dados uma forma de armazenar os dados, e dando-lhe a segurança de
passar strings Unicode aos templates, models e pro banco de dados.</p>
<p>Este documento lhe conta o que você precisa saber se você estiver escrevendo
aplicações que usam dados ou templates que estão codificados em algum outro
formato ASCII.</p>
<div class="section" id="s-criando-o-banco-de-dados">
<span id="criando-o-banco-de-dados"></span><h2>Criando o banco de dados<a class="headerlink" href="#criando-o-banco-de-dados" title="Permalink to this headline">¶</a></h2>
<p>Esteja certo que seu banco de dados está configurado para armazenar strings
arbitrárias. Normalmente, isto significa tê-las numa codificação UTF-8 ou
UTF-16. Se você usa mais de uma codificação restritiva &#8211; por exemplo, latin1
(iso8859-1) &#8211; você não poderá armazenar certos caracteres no banco de dados,
e informações serão perdidas.</p>
<ul class="simple">
<li>Usuários do MySQL, consultem o <a class="reference external" href="http://www.mysql.org/doc/refman/5.1/en/charset-database.html">manual do MySQL</a> (seção 10.3.2 para MySQL
5.1) para detalhes sobre como setar ou alterar a codificação do banco de
dados.</li>
<li>Usuários de PostgreSQL, consultem o <a class="reference external" href="http://www.postgresql.org/docs/8.2/static/multibyte.html#AEN24104">manual do PostgreSQL</a> (seção 21.2.2 no
PostgresSQL 8) para detalhes sobre criar bancos de dados com a codificação
correta.</li>
<li>Usuários de SQLite, não há nada que você precise fazer. O SQLite sepre usa o
UTF-8 para codificação interna.</li>
</ul>
<p>Todos os backends de banco de dados do Django automaticamente covertem strings
Unicode para o formato apropriado do banco de dados. Eles também convertem
automaticamente strings recebidas de bancos de dados em strings Unicode do
Python. Você não precisa dizer ao Django qual codificação seu banco de dados
usa: isso é manipulado transparentemente.</p>
<p>Par mais, veja a seção &#8220;API de banco de dados&#8221; abaixo.</p>
</div>
<div class="section" id="s-manipulacao-generica-de-string">
<span id="manipulacao-generica-de-string"></span><h2>Manipulação genérica de string<a class="headerlink" href="#manipulacao-generica-de-string" title="Permalink to this headline">¶</a></h2>
<p>Sempre que você usa strings com o Django &#8211; e.g., no banco de dados,
renderização de templates ou algo mais &#8211; você tem duas escolhas de codificação
de strings. Você pode usar strings Unicode, ou vocÊ pode usar strings normais (
algumas chamadas &#8220;bytestrings&#8221;) que são codificadas usando UTF-8.</p>
<div class="admonition-warning admonition ">
<p class="first admonition-title">Warning</p>
<p>Uma bytestring não carrega qualquer informação com ela sobre sua
codificação. Por esta razão, nós temos que fazer uma suposição, e o Django
assume que toda bytestring é UTF-8.</p>
<p class="last">Se você passar uma string para o Django que já foi codificada em algum outro
formato, as coisas podem ir por um caminho errado e de formas interessantes.
Normalmente, o Django lançará um erro <tt class="docutils literal"><span class="pre">UnicodeDecodeError</span></tt> neste ponto.</p>
</div>
<p>Se seu código somente usa dados ASCII, ele é seguro para usar strings normais,
passando-as a vontade, porque o ASCII é sub-conjunto do UTF-8.</p>
<p>Não se engane em pensar que se sua configuração <a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> é
qualquer coisa diferente de <tt class="docutils literal"><span class="pre">'utf-8'</span></tt> que você pode usar nas suas bytestrings!
<a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> somente se aplica a strings geradas como resultado de
renderização de templates (e e-mail). O Django sempre assumirá a codificação
UTF-8 para bytestrings internas. A razão disso é que na verdade a configuração
<a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> não está sob seu controle (se você é um desenvolvedor
de aplicações). Está sob controle da pessoa que instala e usa sua aplicação &#8211;
e se essa pessoa escolher uma configuração diferente, seu código pode ainda
continuar funcionando. Portanto, ela não pode contar com essa configuração.</p>
<p>Na maioria dos casos quando o Django está lidando com strings, ele as converterá
para Unicode antes de fazer algo mais. Então, como uma regra geral, se você
passa uma bytestring, esteja preparado para receber uma string Unicode de volta
no resultado.</p>
<div class="section" id="s-strings-traduzidas">
<span id="strings-traduzidas"></span><h3>Strings traduzidas<a class="headerlink" href="#strings-traduzidas" title="Permalink to this headline">¶</a></h3>
<p>Além das string Unicode e bytestrings, há um terceiro tipo de objeto do tipo
string que você pode encontrar enquanto usa o Django. As funcionalidades do
framework de internacionalização introduzem o conceito de uma &#8220;tradução
lazy&#8221; &#8211; uma string que foi marcada como traduzida mas cujo resultado atual da
tradução não é determinado até que o objeto seja utilizado numa string. Esta
funcionalidade é útil em casos onde a localização da tradução é desconhecida até
que a string seja usada, mesmo pensando que a string possa ter sigo
originalmente criada quando o código foi importado pela primeira vez.</p>
<p>Normalmente, você não terá de se preocupar com traduções lazy. Somente esteja
alerta que se você examinar um objeto e ele afirma ser um objeto
<tt class="docutils literal"><span class="pre">django.utils.functional.__proxy__</span></tt>, ele é uma tradução lazy. Chamando
<tt class="docutils literal"><span class="pre">unicode()</span></tt> com a tradução lazy como argumento gerará uma string Unicode na
localização atual.</p>
<p>Para mais detalhes sobre traduções tardias de objetos, leia a documentação de
<a class="reference internal" href="../topics/i18n/index.html"><em>internacionalização</em></a>.</p>
</div>
<div class="section" id="s-utilitario-de-funcoes-uteis">
<span id="utilitario-de-funcoes-uteis"></span><h3>Utilitário de funções úteis<a class="headerlink" href="#utilitario-de-funcoes-uteis" title="Permalink to this headline">¶</a></h3>
<p>Por algumas operações de string serem muito repetitivas, o Django vem
acompanhado de funções úteis que devem fazer o trabalho com objetos Unicode e
bytestring ficar um pouco mais fácil.</p>
<div class="section" id="s-fucoes-de-conversao">
<span id="fucoes-de-conversao"></span><h4>Fuções de conversão<a class="headerlink" href="#fucoes-de-conversao" title="Permalink to this headline">¶</a></h4>
<p>O módulo <tt class="docutils literal"><span class="pre">django.utils.encoding</span></tt> contém algumas funções que são capazes de
realizar conversões entre strings Unicode e bytestrings.</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">smart_unicode(s,</span> <span class="pre">encoding='utf-8',</span> <span class="pre">strings_only=False,</span> <span class="pre">errors='strict')</span></tt>
converte sua entrada para uma string Unicode. O parametro <tt class="docutils literal"><span class="pre">encoding</span></tt>
especifica a codificação da entrada. (Por exemplo, o Django usa isso
internamente quando processa dados de formulários, que podem não ter
codificação UTF-8.) O parametro <tt class="docutils literal"><span class="pre">strings_only</span> <span class="pre">``,</span> <span class="pre">se</span> <span class="pre">setado</span> <span class="pre">como</span> <span class="pre">True,</span>
<span class="pre">resultará</span> <span class="pre">em</span> <span class="pre">números</span> <span class="pre">Python,</span> <span class="pre">booleanos</span> <span class="pre">e</span> <span class="pre">``None</span></tt> sem conversão para uma
string (eles mantêm seus tipos originais). O parametro <tt class="docutils literal"><span class="pre">errors</span></tt> recebe
qualquer um dos valores que são aceitos pela função <tt class="docutils literal"><span class="pre">unicode()</span></tt> do
Python para sua manipulação de erros.</p>
<p>Se você passar ao <tt class="docutils literal"><span class="pre">smart_unicode()</span></tt> um objeto que tem um método
<tt class="docutils literal"><span class="pre">__unicode__</span></tt>, ele usará este método para fazer a conversão.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">force_unicode(s,</span> <span class="pre">encoding='utf-8',</span> <span class="pre">strings_only=False,</span>
<span class="pre">errors='strict')</span></tt> é identico ao <tt class="docutils literal"><span class="pre">smart_unicode()</span></tt> em quase todos os
casos. A diferença é quando o primeiro argumento é uma instância de
<a class="reference internal" href="../topics/i18n/internationalization.html#lazy-translations"><em>tradução lazy</em></a>. Enquanto <tt class="docutils literal"><span class="pre">smart_unicode()</span></tt>
preserva a tradução tardia, <tt class="docutils literal"><span class="pre">force_unicode()</span></tt> força estes objetos a
serem strings Unicode (causando a ocorrência da tradução). Normalmente,
você desejará usar <tt class="docutils literal"><span class="pre">smart_unicode()</span></tt>. Entretanto, <tt class="docutils literal"><span class="pre">force_unicode()</span></tt> é
útil em template tags e filtros que <em>devem</em> ter absolutamente uma string
para trabalhar com, não algo que pode ser convertido numa string.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">smart_str(s,</span> <span class="pre">encoding='utf-8',</span> <span class="pre">strings_only=False,</span> <span class="pre">errors='strict')</span></tt>
é essencialmente o oposto de <tt class="docutils literal"><span class="pre">smart_unicode()</span></tt>. Ele força o primeiro
argumento a ser uma bytestring. O parametro <tt class="docutils literal"><span class="pre">strings_only</span></tt> tem o mesmo
comportamento que do <tt class="docutils literal"><span class="pre">smart_unicode()</span></tt> e <tt class="docutils literal"><span class="pre">force_unicode()</span></tt>. Essa é uma
semântica ligeiramente diferente da função nativa do Python <tt class="docutils literal"><span class="pre">str()</span></tt>,
mas a diferença é necessária em alguns poucos lugares internos do Django.</p>
</li>
</ul>
<p>Normalmente, você somente precisará usar <tt class="docutils literal"><span class="pre">smart_unicode()</span></tt>. Chamando-o tão
cedo quanto possível sobre qualquer entrada de dados que podem ser Unicode ou
bytestring, e a partir de então, você pode tratar os resultados como sempre faz
com Unicode.</p>
</div>
<div class="section" id="s-manipulacao-de-uri-e-iri">
<span id="manipulacao-de-uri-e-iri"></span><h4>Manipulação de URI e IRI<a class="headerlink" href="#manipulacao-de-uri-e-iri" title="Permalink to this headline">¶</a></h4>
<p>Os frameworks Web tem de lidar com URLs (que são um tipo de <a class="reference external" href="http://www.ietf.org/rfc/rfc3987.txt">IRI</a>). Um dos
requerimentos das URLs é que elas são codificadas usando somente caracteres
ASCII. Entretanto, num ambiente internacional, você pode precisar construir uma
URL a partir de uma <a class="reference external" href="http://www.ietf.org/rfc/rfc3987.txt">IRI</a> &#8211; falando muito vagamente, um URI que pode conter
caracteres Unicode. Colocando entre aspas e convertendo uma IRI para URI pode
ser um pouco complicado, então o Django fornece alguma assistência.</p>
<ul class="simple">
<li>A função <tt class="docutils literal"><span class="pre">django.utils.encoding.iri_to_uri()</span></tt> implementa a conversão
de uma IRI para URI como é pedido na especificação (<a class="reference external" href="http://www.ietf.org/rfc/rfc3987.txt">RFC 3987</a>).</li>
<li>As funções <tt class="docutils literal"><span class="pre">django.utils.http.urlquote()</span></tt> e
<tt class="docutils literal"><span class="pre">django.utils.http.urlquote_plus()</span></tt> são versões ao padrão Python
<tt class="docutils literal"><span class="pre">utllib.quote()</span></tt> e <tt class="docutils literal"><span class="pre">urllib.quote_plus()</span></tt> que trabalham com caracteres
não-ASCII. (O dado é convertido para UTF-8 antes da codificação.)</li>
</ul>
<p>Estes dois grupos de funções têm efeitos ligeiramente diferentes, e é importante
mante-los distintos. Normalmente, você usaria <tt class="docutils literal"><span class="pre">urlquote()</span></tt> nas porções
individuais de caminhos IRI ou URI de modo que quaisquer caracteres reservados
como &#8216;&amp;&#8217; ou &#8216;%&#8217; sejam corretamente codificados. Depois, você aplica
<tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> para o IRI completo e ele converte quaisquer caracteres
não-ASCII para os valores codificados corretos.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Tecnicamente, não é correto dizer que <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> implementa o
algoritmo completo da especificação IRI. Ele (ainda) não faz a codificação
de nomes de domnínios internacinais, que é uma porção do algoritmo.</p>
</div>
<p>A função <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> não mudará caracteres ASCII que são de outra forma
permitidos em uma URL. Então, por exemplo, o caractere &#8216;%&#8217; não é mais codificado
quando passado para <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt>. Isso significa que você pode passar uma
URL completa para essa função e ela não bagunçará a query string ou qualquer
coisa do tipo.</p>
<p>Um exemplo pode clarear as coisas aqui:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">urlquote</span><span class="p">(</span><span class="s">u&#39;Paris &amp; Orléans&#39;</span><span class="p">)</span>
<span class="go">u&#39;Paris%20%26%20Orl%C3%A9ans&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iri_to_uri</span><span class="p">(</span><span class="s">u&#39;/favorites/François/</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">urlquote</span><span class="p">(</span><span class="s">u&#39;Paris &amp; Orléans&#39;</span><span class="p">))</span>
<span class="go">&#39;/favorites/Fran%C3%A7ois/Paris%20%26%20Orl%C3%A9ans&#39;</span>
</pre></div>
</div>
<p>Se você olhar cuidadosamente, você poderá ver que a porção que foi gerada pelo
<tt class="docutils literal"><span class="pre">urlquote()</span></tt> no segundo exemplo, não foi duplamente cotada quando passou pelo
<tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt>. Essa é uma funcionalidade muito importante e útil. Ela
significa que você pode construir suas IRI sem se preocupar se ela contém
caracteres não-ASCII e então, bem no final, chame <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> sobre o
resultado.</p>
<p>A função <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> é também imutável, o que significa que o seguinte é
sempre verdadeiro:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">iri_to_uri</span><span class="p">(</span><span class="n">iri_to_uri</span><span class="p">(</span><span class="n">some_string</span><span class="p">))</span> <span class="o">=</span> <span class="n">iri_to_uri</span><span class="p">(</span><span class="n">some_string</span><span class="p">)</span>
</pre></div>
</div>
<p>Então você pode seguramente chamá-lo várias vezes sobre a mesma IRI sem o risco
de ploblemas com dupla-cotação.</p>
</div>
</div>
</div>
<div class="section" id="s-models">
<span id="models"></span><h2>Models<a class="headerlink" href="#models" title="Permalink to this headline">¶</a></h2>
<p>Como todas as strings são retornadas de um banco de dados como strings Unicode,
os campos de model que são baseados em caracteres (CharField, TextField,
URLField, etc) conterão valores Unicode quando o Django recebe dados de um banco
de dados. O caso é <em>sempre</em> esse, mesmo que os dados pudessem caber numa
bytestring ASCII.</p>
<p>Você pode passar dados em bytestrings quando estiver criando um model ou
populando um campo, mas o Django o converterá para Unicode quando ele precisar.</p>
<div class="section" id="s-escolhendo-entre-str-e-unicode">
<span id="escolhendo-entre-str-e-unicode"></span><h3>Escolhendo entre <tt class="docutils literal"><span class="pre">__str__()</span></tt> e <tt class="docutils literal"><span class="pre">__unicode__()</span></tt><a class="headerlink" href="#escolhendo-entre-str-e-unicode" title="Permalink to this headline">¶</a></h3>
<p>Uma das consequências de se usar o Unicode por padrão é que você tem de tomar
cuidado quando for imprimir dados de um model.</p>
<p>Em particular, ao invés de dar ao seu model um método <tt class="docutils literal"><span class="pre">__str__()</span></tt>, nós
recomendamos você implementar um método <tt class="docutils literal"><span class="pre">__unicode__()</span></tt>. No método
<tt class="docutils literal"><span class="pre">__unicode__()</span></tt>, você pode seguramente retornar valores de todos os campos sem
ter de se preocupar se eles irão caber dentro de uma bytestring ou não. (A forma
como o Python trabalha, o resultado de <tt class="docutils literal"><span class="pre">__str__()</span></tt> é <em>sempre</em> uma bytestring,
mesmo se você acidentalmente tentar retornar um objeto Unicode).</p>
<p>Você pode ainda criar um método <tt class="docutils literal"><span class="pre">__str__()</span></tt> nos seus models se você quiser,
é claro, mas você não precisa fazer isso a menos que tenha uma boa razão.
O classe base <tt class="docutils literal"><span class="pre">Model</span></tt> do Django fornece automaticamente uma implementação do
método <tt class="docutils literal"><span class="pre">__str__()</span></tt> que chama <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> e codifica o resultado para
UTF-8. Isso significa que você normalmente precisará somente implentar um método
<tt class="docutils literal"><span class="pre">__unicode__()</span></tt> e deixar o Django manipular a coerção para uma bytestring
quando for requerido.</p>
</div>
<div class="section" id="s-tome-cuidado-no-get-absolute-url">
<span id="tome-cuidado-no-get-absolute-url"></span><h3>Tome cuidado no <tt class="docutils literal"><span class="pre">get_absolute_url()</span></tt><a class="headerlink" href="#tome-cuidado-no-get-absolute-url" title="Permalink to this headline">¶</a></h3>
<p>URLs podem somente conter caracteres ASCII. Se você estiver construíndo uma URL
a partir de dados que podem ser não-ASCII, tenha cuidado para codificar os
resultados de uma forma que seja adequada para uma URL. O decorador
<tt class="docutils literal"><span class="pre">django.db.models.permalink()</span></tt> automaticamente manipula isso automaticamente
por você.</p>
<p>Se você estiver construíndo uma URL manualmente (i.e., <em>sem</em> usar o decorador
<tt class="docutils literal"><span class="pre">permalink()</span></tt>), você precisará se preocupar em codificar você mesmo. Neste
caso use, use as funções <tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> e <tt class="docutils literal"><span class="pre">urlquote()</span></tt> que foram
documentadas <a class="reference internal" href="#manipulacao-de-uri-e-iri">acima</a>. Por exemplo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.utils.encoding</span> <span class="kn">import</span> <span class="n">iri_to_uri</span>
<span class="kn">from</span> <span class="nn">django.utils.http</span> <span class="kn">import</span> <span class="n">urlquote</span>

<span class="k">def</span> <span class="nf">get_absolute_url</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">u&#39;/person/</span><span class="si">%s</span><span class="s">/?x=0&amp;y=0&#39;</span> <span class="o">%</span> <span class="n">urlquote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iri_to_uri</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</pre></div>
</div>
<p>Essa função retorna um URL corretamente codificada mesmo se <tt class="docutils literal"><span class="pre">self.location</span></tt>
seja algo tipo &quot;Jack visited Paris &amp; Orléans&quot;. (De fato, a chamada
<tt class="docutils literal"><span class="pre">iri_to_uri()</span></tt> não é estritamente necessária no exemplo acima, pois todos os
caracteres não-ASCII já foram removidos durante o <tt class="docutils literal"><span class="pre">urlquote()</span></tt> na primeira
linha.)</p>
</div>
</div>
<div class="section" id="s-a-api-de-banco-de-dados">
<span id="a-api-de-banco-de-dados"></span><h2>A API de banco de dados<a class="headerlink" href="#a-api-de-banco-de-dados" title="Permalink to this headline">¶</a></h2>
<p>Você pode passar tanto strings Unicode ou bytestrings UTF-8 como argumentos para
os métodos <tt class="docutils literal"><span class="pre">filter()</span></tt> e seus semelhantes da API de banco de dados. Os dois
querysets a seguir são identicos:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">qs</span> <span class="o">=</span> <span class="n">People</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">u&#39;Å&#39;</span><span class="p">)</span>
<span class="n">qs</span> <span class="o">=</span> <span class="n">People</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\xc3\x85</span><span class="s">&#39;</span><span class="p">)</span> <span class="c"># Codificação UTF-8 de Å</span>
</pre></div>
</div>
</div>
<div class="section" id="s-templates">
<span id="templates"></span><h2>Templates<a class="headerlink" href="#templates" title="Permalink to this headline">¶</a></h2>
<p>Você pode usar tanto Unicode quanto bytestrings quando criar templates
manualmente:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.template</span> <span class="kn">import</span> <span class="n">Template</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s">&#39;This is a bytestring template.&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s">u&#39;This is a Unicode template.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Porém o caso mais comum é ler os templates do sistema de arquivos, e isso gera
uma ligeira complicação: nem todos os sistemas de arquivos armazenam seus dados
codificados em UTF-8. Se seus arquivos de template não são armazenados com
codificação UTF-8, configure o <a class="reference internal" href="settings.html#std:setting-FILE_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">FILE_CHARSET</span></tt></a> para codificar os
arquivos no disco. Quando o Django lê um arquivo de template, ele converterá
os dados dele para Unicode. (<a class="reference internal" href="settings.html#std:setting-FILE_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">FILE_CHARSET</span></tt></a> é configurado como
<tt class="docutils literal"><span class="pre">'utf-8'</span></tt> por padrão.)</p>
<p>A configuração <a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> controla a codificação de templates
renderizados. Isto é configurado como UTF-8 por padrão.</p>
<div class="section" id="s-template-tags-e-filtros">
<span id="template-tags-e-filtros"></span><h3>Template tags e filtros<a class="headerlink" href="#template-tags-e-filtros" title="Permalink to this headline">¶</a></h3>
<p>Algumas dicas para se lembrar quando escrever suas próprias template tags e
filtros:</p>
<ul class="simple">
<li>Sempre retorne strings Unicode de um método render de uma template tag e
de um filtro.</li>
<li>Use <tt class="docutils literal"><span class="pre">force_unicode()</span></tt> de preferência, ao invés de <tt class="docutils literal"><span class="pre">smart_unicode()</span></tt>
nestes lugares. As chamadas de renderização de tags e filtros ocorrem
quando o template estiver em renderização, assim não há vantagem em adiar
a conversão de objetos de traduções lazy. É mais fácil trabalhar
unicamente com strings Unicode neste ponto.</li>
</ul>
</div>
</div>
<div class="section" id="s-e-mail">
<span id="e-mail"></span><h2>E-mail<a class="headerlink" href="#e-mail" title="Permalink to this headline">¶</a></h2>
<p>O framework de email do Django (em <tt class="docutils literal"><span class="pre">django.core.mail</span></tt>) suporta Unicode
transparentemente. Você pode usar dados Unicode no corpo das mensagens e
qualquer cabeçalho. Entretanto, você ainda será obrigado a respeitar os
requerimentos das especificações do e-mail, desta forma, por exemplo, endereços
de e-mail devem usar somente caracteres ASCII.</p>
<p>O seguinte código de exemplo demonstra que tudo, exceto endereços de e-mail,
podem ser não ASCII:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.core.mail</span> <span class="kn">import</span> <span class="n">EmailMessage</span>

<span class="n">subject</span> <span class="o">=</span> <span class="s">u&#39;My visit to Sør-Trøndelag&#39;</span>
<span class="n">sender</span> <span class="o">=</span> <span class="s">u&#39;Arnbjörg Ráðormsdóttir &lt;arnbjorg@example.com&gt;&#39;</span>
<span class="n">recipients</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Fred &lt;fred@example.com&#39;</span><span class="p">]</span>
<span class="n">body</span> <span class="o">=</span> <span class="s">u&#39;...&#39;</span>
<span class="n">EmailMessage</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="n">recipients</span><span class="p">)</span><span class="o">.</span><span class="n">send</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-submissao-de-formularios">
<span id="submissao-de-formularios"></span><h2>Submissão de formulários<a class="headerlink" href="#submissao-de-formularios" title="Permalink to this headline">¶</a></h2>
<p>Submissão de formulários HTML é uma área complicada. Não há garantias de que a
submissão incluirá informações de codificação, o que significa que o framework
pode ter de advinhar a codificação dos dados submetidos.</p>
<p>O Django adota uma abordagem &quot;lazy&quot; para decodificar dados de formulário. Os
dados num objeto <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> é somente decodificado quando você o acessa. De
fato, a maior parte dos dados não é decodificada. Somente as estruturas de dados
<tt class="docutils literal"><span class="pre">HttpRequest.GET</span></tt> e <tt class="docutils literal"><span class="pre">HttpRequest.POST</span></tt> tem qualquer decodificação aplicada
nelas. Estes dois campos retornar]ao seus membros como dados Unicode. Todos os
outros atributos e método do <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> retornam exatamente o dado como
foi submetido pelo cliente.</p>
<p>Por padrão, a configuração <a class="reference internal" href="settings.html#std:setting-DEFAULT_CHARSET"><tt class="xref std std-setting docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt></a> é usada como a codificação
assumida pelos dados do formulário. Se você precisa mudar isso para um
formulário particular, você pode configurar o atributo <tt class="docutils literal"><span class="pre">encoding</span></tt> de uma
instância <tt class="docutils literal"><span class="pre">HttpRequest</span></tt>. Por exemplo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">some_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c"># Nós sabemos que os dados devem ser codificados como KOI8-R</span>
    <span class="c"># (por alguma razão).</span>
    <span class="n">request</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="s">&#39;koi8-r&#39;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Você ainda pode mudar a codificação depois de accessado o <tt class="docutils literal"><span class="pre">request.GET</span></tt> ou
<tt class="docutils literal"><span class="pre">request.POST</span></tt>, e todos os acessos subsequentes usarão a nova codificação.</p>
<p>A maioria dos desenvolvedores não precisam se preocupar em mudar a codificação
de um formulário, mas essa é uma funcionalidade útil quando falamos de sistemas
legadas cuja codificação você não pode controlar.</p>
<p>O django não codifica dados de arquivos de upload, pois esses dados são
normalmente tratados como coleções de bytes, ao invés de strings. Qualquer
decodificação automática não alteraria o sentido do fluxo de bytes.</p>
</div>
</div>


          </div>         
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Dados Unicode no Django</a><ul>
<li><a class="reference internal" href="#criando-o-banco-de-dados">Criando o banco de dados</a></li>
<li><a class="reference internal" href="#manipulacao-generica-de-string">Manipulação genérica de string</a><ul>
<li><a class="reference internal" href="#strings-traduzidas">Strings traduzidas</a></li>
<li><a class="reference internal" href="#utilitario-de-funcoes-uteis">Utilitário de funções úteis</a><ul>
<li><a class="reference internal" href="#fucoes-de-conversao">Fuções de conversão</a></li>
<li><a class="reference internal" href="#manipulacao-de-uri-e-iri">Manipulação de URI e IRI</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#models">Models</a><ul>
<li><a class="reference internal" href="#escolhendo-entre-str-e-unicode">Escolhendo entre <tt class="docutils literal"><span class="pre">__str__()</span></tt> e <tt class="docutils literal"><span class="pre">__unicode__()</span></tt></a></li>
<li><a class="reference internal" href="#tome-cuidado-no-get-absolute-url">Tome cuidado no <tt class="docutils literal"><span class="pre">get_absolute_url()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-api-de-banco-de-dados">A API de banco de dados</a></li>
<li><a class="reference internal" href="#templates">Templates</a><ul>
<li><a class="reference internal" href="#template-tags-e-filtros">Template tags e filtros</a></li>
</ul>
</li>
<li><a class="reference internal" href="#e-mail">E-mail</a></li>
<li><a class="reference internal" href="#submissao-de-formularios">Submissão de formulários</a></li>
</ul>
</li>
</ul>

  <h3>Browse</h3>
  <ul>
    
      <li>Prev: <a href="templates/api.html">A linguagem de template do Django: Para programadores Python</a></li>
    
    
      <li>Next: <a href="utils.html">Django Utils</a></li>
    
  </ul>
  <h3>Você está aqui:</h3>
  <ul>
      <li>
        <a href="../index.html">Django v1.3.1 documentation</a>
        
          <ul><li><a href="index.html">Referência da API</a>
        
        <ul><li>Dados Unicode no Django</li></ul>
        </li></ul>
      </li>
  </ul>  

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/ref/unicode.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Última atualização:</h3>
              <p class="topless">Dec 06, 2011</p>
          </div> 
        
      
    </div>
    
    <div id="ft">
      <div class="nav">
    &laquo; <a href="templates/api.html" title="A linguagem de template do Django: Para programadores Python">previous</a> 
     |
    <a href="index.html" title="Referência da API" accesskey="U">up</a>
   |
    <a href="utils.html" title="Django Utils">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>