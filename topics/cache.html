
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>O framework de cache do Django &mdash; Django v1.3.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Django v1.3.1 documentation" href="../index.html" />
    <link rel="up" title="Usando o Django" href="index.html" />
    <link rel="next" title="Conditional View Processing" href="conditional-view-processing.html" />
    <link rel="prev" title="Autenticação de Usuário no Django" href="auth.html" />
 
<script type="text/javascript" src="../templatebuiltins.js"></script>
<script type="text/javascript">
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);
</script>

  </head>
  <body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django v1.3.1 documentation</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Tabela de conteúdos" href="../contents.html">Tabela de conteúdos</a>  |
        <a title="Índice Global" href="../genindex.html">Índice</a>  |
        <a title="Busca" href="../py-modindex.html">Módulos</a>
      </div>
      <div class="nav">
    &laquo; <a href="auth.html" title="Autenticação de Usuário no Django">previous</a> 
     |
    <a href="index.html" title="Usando o Django" accesskey="U">up</a>
   |
    <a href="conditional-view-processing.html" title="Conditional View Processing">next</a> &raquo;</div>
    </div>
    
    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-cache">
            
  <div class="section" id="s-o-framework-de-cache-do-django">
<span id="o-framework-de-cache-do-django"></span><h1>O framework de cache do Django<a class="headerlink" href="#o-framework-de-cache-do-django" title="Permalink to this headline">¶</a></h1>
<p>Uma dilema essencial dos sites dinâmicos vem a ser o próprio fato de serem dinâmicos.
Cada vez que um usuário requisita uma página, o servidor web faz todo o tipo de
cálculos &#8211; consultas a bancos de dados, renderização de templates e lógica de negócio &#8211;
para criar a página que o seu visitante vê. Isso tem um custo de processamento
muito maior que apenas a leitura de arquivos estáticos no disco.</p>
<p>Para a maior parte dos aplicativos Web, esse overhead não é um problema. A maior
parte das aplicações Web não são o washingtonpost.com oouslashdot.org; são simplesmente sites
pequenos a médio com tráfico equivalente. Mas para aplicações de porte mério para grante,
é essencial eliminar toda a sobrecarga possível.</p>
<p>É onde entra o cache.</p>
<p>Fazer o cache de algo é gravar o resultado de um cálculo custoso para que
você não tenha de executar o cálculo da próxima vez. Aqui está um pseudocódigo
explicando como isso funcionaria para uma página Web gerada dinamicamente:</p>
<div class="highlight-python"><pre>tente encontrar uma página no cache para tal URL
se a página estiver no cache:
    retorne a página do cache
se não:
    gere a página
    guarde a página gerada no cache (para a próxima vez)
    retorne a página gerada</pre>
</div>
<p>O Django vem com um sistema de cache robusto que permite que você guarde as páginas dinâmicas para que
elas não tenham de ser calculadas a cada requisição. Por conveniência, Django
oferece diferentes níveis de granularidade de cache: Você pode fazer o cache da saída de
views específicas, você pode fazer o cache somente das partes que são difíceis de produzir, ou
pode fazer o cache do site inteiro.</p>
<p>O Django também trabalha com caches do tipo &quot;upstream&quot;, como o Squid
(<a class="reference external" href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>) e cache baseado em navegador. Esses são tipos de cache
que você não controla diretamente mas para os quais fornece dicas (via
cabeçalhos HTTP) sobre quais partes do seu site devem ser mantidas em cache, e como.</p>
<div class="section" id="s-configurando-o-cache">
<span id="configurando-o-cache"></span><h2>Configurando o cache<a class="headerlink" href="#configurando-o-cache" title="Permalink to this headline">¶</a></h2>
<p>O sistema de cache requer uma pequena configuração. Você deve informar
ao Django onde os seus dados em cache estarão -- se em um banco de dados, no sistema de
arquivos ou diretamente na memória. Essa é uma decisão importante que afeta a performance
do seu cache; sim, algums tipos de cache são mais rápidos que outros.</p>
<p>Sua preferência de cache vai na configuração <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> no seu arquivo de
configurações. Aqui vai uma explicação de todos os valores disponíveis para
<tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt>.</p>
<div class="section" id="s-memcached">
<span id="memcached"></span><h3>Memcached<a class="headerlink" href="#memcached" title="Permalink to this headline">¶</a></h3>
<p>De longe, o mais rápido e mais eficiente tipo de cache disponível no Django, Memcached
é um framework de cache inteiramente baseado em memória originalmente desenvolvido para
lidar com as altas cargas no LiveJournal.com e subsequentemente tornada open-sourced pela Danga
Interactive. É usado por sites como o Facebook ou Wikipedia para reduzir o acesso a banco de dados
e aumentar a performance do site drasticamente.</p>
<p>O Memcached está disponível de graça em <a class="reference external" href="http://memcached.org/">http://memcached.org/</a> . Ele executa como um
daemon, para o qual é alocada uma quantidade específica de RAM. Tudo o que ele faz é fornecer
uma interface rápida para adição, busca e remoção de dados arbitrários do cache.
Todos os dados são gravados diretamente na memória, então não existe sobrecarga
de banco de dados ou uso do filesystem.</p>
<p>Após a instalação do Memcached, você precisa instalar o
<tt class="docutils literal"><span class="pre">python-memcached</span></tt>, which provides Python bindings to Memcached.
This is available at <a class="reference external" href="ftp://ftp.tummy.com/pub/python-memcached/">ftp://ftp.tummy.com/pub/python-memcached/</a></p>
<div class="versionchanged">
<span class="title">Changed in Django 1.2:</span> In Django 1.0 and 1.1, you could also use <tt class="docutils literal"><span class="pre">cmemcache</span></tt> as a binding.
However, support for this library was deprecated in 1.2 due to
a lack of maintenance on the <tt class="docutils literal"><span class="pre">cmemcache</span></tt> library itself. Support for
<tt class="docutils literal"><span class="pre">cmemcache</span></tt> will be removed completely in Django 1.4.</div>
<p>Para usar o Memcached com Django, configure o  <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> para
<tt class="docutils literal"><span class="pre">memcached://ip:port/</span></tt>, onde <tt class="docutils literal"><span class="pre">ip</span></tt> é o endereço IP dp daemon do Memcached
e o <tt class="docutils literal"><span class="pre">port</span></tt> é a porta onde o Memcached está rodando.</p>
<p>Nesse exemplo, o Memcached está rodando em localhost (127.0.0.1) na porta 11211:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;memcached://127.0.0.1:11211/&#39;</span>
</pre></div>
</div>
<p>Uma característica excelente do Memcached é sua habilidade de compartilhar o cache
em diversos servidores. Isso significa que você pode executar daemons do Memcached em diversas máquinas,e
o programa irá tratar o grupo de máquinas como um <em>único</em> cache, sem a necessidade de duplicar
os valores do cache em cada máquina.Para aproveitar essa funcionalidade, inclua todos os endereços
de servidores em <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt>, separados por ponto e vírgula.</p>
<p>In this example, the cache is shared over Memcached instances running on IP
address 172.19.26.240 and 172.19.26.242, both on port 11211:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;memcached://172.19.26.240:11211;172.19.26.242:11211/&#39;</span>
</pre></div>
</div>
<p>Nesse exemplo, o cache é compartilhado por instâncias do  Memcached rodando nos endereços IP
172.19.26.240 (porta 11211) e 172.19.26.242 (port 11212), e
172.19.26.244 (porta 11213):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;memcached://172.19.26.240:11211;172.19.26.242:11212;172.19.26.244:11213/&#39;</span>
</pre></div>
</div>
<p>O cache baseado em memória tem uma desvantagem: Como os dados em cache estão na
memória, serão perdidos se o seu servidor travar. Claramente, a memória não
foi feita para armazenamento permanente de dados, então não confie no cache em
memória como sua única fonte de armazenamento de dados. Na verdade, nenhum dos
backends de cache do Django deve ser usado para armazenamento permanente --
devem ser usados como soluções para cache, e não armazenamento -- mas
reafirmamos isso aqui porque o cache em memória é realmente temporário.</p>
</div>
<div class="section" id="s-cache-em-banco-de-dados">
<span id="cache-em-banco-de-dados"></span><h3>Cache em banco de dados<a class="headerlink" href="#cache-em-banco-de-dados" title="Permalink to this headline">¶</a></h3>
<p>Para usar uma tabela do banco de dados como o seu backend de cache, primeiro
crie uma tabela de cache em seu banco de dados com o seguinte comando:</p>
<div class="highlight-python"><pre>python manage.py createcachetable [cache_table_name]</pre>
</div>
<p>...onde <tt class="docutils literal"><span class="pre">[cache_table_name]</span></tt> é o nome da tabela no banco de dados a ser criada.
(Esse nome pode ser qualquer um, desde que seja um nome válido de tabela e esse nome
ainda não esteja sendo usado no seu banco de dados.) Esse comando cria uma única tabela
no seu banco de dados, no formato apropriado que o sistema de cache em banco de dados
do Django espera encontrar.</p>
<p>Uma vez que você tenha configurado a tabela do banco de dados, configure o seu <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt>
para <tt class="docutils literal"><span class="pre">&quot;db://tablename&quot;</span></tt>, onde <tt class="docutils literal"><span class="pre">tablename</span></tt> é o nome da tabela.
Nesse exemplo, o nome da tabela de cache é <tt class="docutils literal"><span class="pre">my_cache_table</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;db://my_cache_table&#39;</span>
</pre></div>
</div>
<p>O cache em banco de dados usará o mesmo banco de dados especificado em seu
arquivo de configuração. Você não pode usar um banco de dados diferente para sua tabela de cache.</p>
<p>O cache em banco de dados funciona melhor se você tem um servidor de banco de dados rápido
e bem indexado.</p>
<div class="section" id="s-database-caching-and-multiple-databases">
<span id="database-caching-and-multiple-databases"></span><h4>Database caching and multiple databases<a class="headerlink" href="#database-caching-and-multiple-databases" title="Permalink to this headline">¶</a></h4>
<p>If you use database caching with multiple databases, you'll also need
to set up routing instructions for your database cache table. For the
purposes of routing, the database cache table appears as a model named
<tt class="docutils literal"><span class="pre">CacheEntry</span></tt>, in an application named <tt class="docutils literal"><span class="pre">django_cache</span></tt>. This model
won't appear in the models cache, but the model details can be used
for routing purposes.</p>
<p>For example, the following router would direct all cache read
operations to <tt class="docutils literal"><span class="pre">cache_slave</span></tt>, and all write operations to
<tt class="docutils literal"><span class="pre">cache_master</span></tt>. The cache table will only be synchronized onto
<tt class="docutils literal"><span class="pre">cache_master</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CacheRouter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A router to control all database cache operations&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">db_for_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="s">&quot;All cache read operations go to the slave&quot;</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">app_label</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;django_cache&#39;</span><span class="p">,):</span>
            <span class="k">return</span> <span class="s">&#39;cache_slave&#39;</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">db_for_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="s">&quot;All cache write operations go to master&quot;</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">app_label</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;django_cache&#39;</span><span class="p">,):</span>
            <span class="k">return</span> <span class="s">&#39;cache_master&#39;</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">allow_syncdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="s">&quot;Only synchronize the cache model on master&quot;</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">app_label</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;django_cache&#39;</span><span class="p">,):</span>
            <span class="k">return</span> <span class="n">db</span> <span class="o">==</span> <span class="s">&#39;cache_master&#39;</span>
        <span class="k">return</span> <span class="bp">None</span>
</pre></div>
</div>
<p>If you don't specify routing directions for the database cache model,
the cache backend will use the <tt class="docutils literal"><span class="pre">default</span></tt> database.</p>
<p>Of course, if you don't use the database cache backend, you don't need
to worry about providing routing instructions for the database cache
model.</p>
</div>
</div>
<div class="section" id="s-cache-em-sistema-de-arquivos">
<span id="cache-em-sistema-de-arquivos"></span><h3>Cache em sistema de arquivos<a class="headerlink" href="#cache-em-sistema-de-arquivos" title="Permalink to this headline">¶</a></h3>
<p>Para gravar os items em cache no sistema de arquivos, use o tipo de cache <tt class="docutils literal"><span class="pre">&quot;file://&quot;</span></tt>
para <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt>. Por exemplo, para salvar os dados do cache em <tt class="docutils literal"><span class="pre">/var/tmp/django_cache</span></tt>,
use essa configuração:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;file:///var/tmp/django_cache&#39;</span>
</pre></div>
</div>
<p>Perceba que existem três barras próximas ao início do exemplo.
As primeiras são para o <tt class="docutils literal"><span class="pre">file://</span></tt>, e a terceira é o primeiro caractere do
caminho do diretório, <tt class="docutils literal"><span class="pre">/var/tmp/django_cache</span></tt>. Se você está no Windows, coloque
a letra do drive após o <tt class="docutils literal"><span class="pre">file://</span></tt>, dessa forma:</p>
<div class="highlight-python"><pre>file://c:/foo/bar</pre>
</div>
<p>O caminho do diretório deve ser absoluto -- isso é, ele deve iniciar na raiz
do seu sistema de arquivos. Não faz diferença se você põe a barra no final
da configuração.</p>
<p>Assegure-se que o diretório apontado por essa configuração exista e tenha permissões
de leitura e escrita pelo usuário do sistema que executa o seu servidor web.
Continuando o exemplo acima, se o seu servidor web roda como o usuário <tt class="docutils literal"><span class="pre">apache</span></tt>,
tenha certeza que o diretório <tt class="docutils literal"><span class="pre">/var/tmp/django_cache</span></tt> exista e tenha permissão de
leitura e escrita pelo usuário <tt class="docutils literal"><span class="pre">apache</span></tt>.</p>
<p>Cada valor de cache será gravado em um arquivo separado cujos conteúdos
são os dados servidos pelo cache em um formato serializado (&quot;pickled&quot;),
usando o módulo <tt class="docutils literal"><span class="pre">pickle</span></tt> do Python. Cada nome de arquivo é a chave do cache,
escapado para uso seguro em sistema de arquivos.</p>
</div>
<div class="section" id="s-cache-em-memoria-local">
<span id="cache-em-memoria-local"></span><h3>Cache em memória local<a class="headerlink" href="#cache-em-memoria-local" title="Permalink to this headline">¶</a></h3>
<p>Se você quer as vantagens de velocidade de executar um cache em memória mas não
pode executar o  Memcached, considere o backend de cache em memória local. Esse
cache é multi-processo e thread-safe. Para usá-lo, configure o <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> para
<tt class="docutils literal"><span class="pre">&quot;locmem:///&quot;</span></tt>. Por exemplo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;locmem:///&#39;</span>
</pre></div>
</div>
<p>Note que cada processo irá ter sua própria instância privada de cache, o que significa
que nenhum cache entre processos é possível. Isso obviamente significa que o cache em
memória local não é muito eficiente em termos de memória, então provavelmente não é
uma boa escolha para um ambiente de produção. É bom para desenvolvimento.</p>
</div>
<div class="section" id="s-cache-falso-para-desenvolvimento">
<span id="cache-falso-para-desenvolvimento"></span><h3>Cache falso (para desenvolvimento)<a class="headerlink" href="#cache-falso-para-desenvolvimento" title="Permalink to this headline">¶</a></h3>
<p>Finalmente, o Django vem com um cache &quot;falso&quot; que não faz cache realmente -- ele
apenas implementa a interface de cache sem fazer nada realmente.</p>
<p>Isso é útil se você tem um site em produção que usa cacheamento pesado em
vários lugares, mas em desenvolvimento ou no ambiente de testes você não quer
usar cache e não quer mudar o código para lidar com o última caso em especial. Para
ativar o cache falso, configure o <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> assim:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;dummy:///&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-usando-um-backend-de-cache-personalizado">
<span id="usando-um-backend-de-cache-personalizado"></span><h3>Usando um backend de cache personalizado<a class="headerlink" href="#usando-um-backend-de-cache-personalizado" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 1.0:</span> <a class="reference internal" href="../releases/1.0.html"><em>Please, see the release notes</em></a></div>
<p>Apesar do Django suportar diversos sistemas de cache diferentes,
algumas vezes você pode querer usar algum backend de cache personalizado. Para usar um
backend externo de cache com o  Django, use um caminho de importação de módulos do Python
como a parte do esquema (a parte que vem antes do dois pontos inicial) da URI do
<tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt>, assim:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;path.to.backend://&#39;</span>
</pre></div>
</div>
<p>Se você está construindo o seu próprio backend, você pode usar os backends padrão
de cache como implementações de referência. Você irá encontrar o código no diretório
<tt class="docutils literal"><span class="pre">django/core/cache/backends/</span></tt> dos fontes do Django.</p>
<p>Nota: Você deveria usar os backends de cache incluídos com o Django, anão ser que você
tenha uma razão muito boa, como um host que não os suporta. Eles foram
bem testados e são fáceis de usar.</p>
</div>
<div class="section" id="s-argumentos-do-cache-backend">
<span id="argumentos-do-cache-backend"></span><h3>Argumentos do CACHE_BACKEND<a class="headerlink" href="#argumentos-do-cache-backend" title="Permalink to this headline">¶</a></h3>
<p>Cada tipo de cache pode receber argumentos. Eles são informados em um estilo semelhante a
query-string na configuração <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt>. Os seguintes argumentos são válidos:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">timeout</span></tt>: O timeout padrão, em segundos, a ser usado para o cache. O padrão é 300</dt>
<dd><p class="first last">segundos (5 minutos).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">max_entries</span></tt>: Para os backends <tt class="docutils literal"><span class="pre">locmem</span></tt>,  <tt class="docutils literal"><span class="pre">filesystem</span></tt> e <tt class="docutils literal"><span class="pre">database</span></tt>,</dt>
<dd><p class="first last">o número máximo de entradas permitidas no cache antes dos valores antigos serem
removidos. O valor padrão desse argumento é 300.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">cull_frequency</span></tt>: A fração de entradas que são limpas do cache quando</dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">max_entries</span></tt> é atingido. A razão real é <tt class="docutils literal"><span class="pre">1/cull_percentage</span></tt>, então
configure o <tt class="docutils literal"><span class="pre">cull_percentage=2</span></tt> para limpar metadae das entradas quando o valor de <tt class="docutils literal"><span class="pre">max_entries</span></tt>
for atingido.</p>
<p class="last">Um valor de <tt class="docutils literal"><span class="pre">0</span></tt> para o <tt class="docutils literal"><span class="pre">cull_frequency</span></tt> significa que o cache todo
será limpo quando <tt class="docutils literal"><span class="pre">max_entries</span></tt> for atingido. Isso torna a limpeza <em>muito</em> mais rápida,
a custa de mais perdas no cache.</p>
</dd>
</dl>
</li>
</ul>
<p>Nesse exemplo, o  <tt class="docutils literal"><span class="pre">timeout</span></tt> está configurado para <tt class="docutils literal"><span class="pre">60</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&quot;memcached://127.0.0.1:11211/?timeout=60&quot;</span>
</pre></div>
</div>
<p>Nesse exemplo, o <tt class="docutils literal"><span class="pre">timeout</span></tt> é <tt class="docutils literal"><span class="pre">30</span></tt> e <tt class="docutils literal"><span class="pre">max_entries</span></tt> é <tt class="docutils literal"><span class="pre">400</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&quot;locmem:///?timeout=30&amp;max_entries=400&quot;</span>
</pre></div>
</div>
<p>Argumentos inválidos são silenciosamente ignorados, assim como valores inválidos para
argumentos conhecidos.</p>
</div>
</div>
<div class="section" id="s-o-cache-por-site">
<span id="o-cache-por-site"></span><h2>O cache por site<a class="headerlink" href="#o-cache-por-site" title="Permalink to this headline">¶</a></h2>
<div class="versionchanged">
<span class="title">Changed in Django 1.0:</span> (versões anteriores do Django forneciam apenas um único <tt class="docutils literal"><span class="pre">CacheMiddleware</span></tt> no lugar
das duas partes descritas abaixo).</div>
<p>Uma vez que o cache esteja configurado, a forma mais siples de usá-lo é fazer
o cache do seu site inteiro. Você precisa adicionar
<tt class="docutils literal"><span class="pre">'django.middleware.cache.UpdateCacheMiddleware'</span></tt> e
<tt class="docutils literal"><span class="pre">'django.middleware.cache.FetchFromCacheMiddleware'</span></tt> as suas configurações de
<tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt>, como nesse exemplo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MIDDLEWARE_CLASSES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s">&#39;django.middleware.cache.UpdateCacheMiddleware&#39;</span><span class="p">,</span>
    <span class="s">&#39;django.middleware.common.CommonMiddleware&#39;</span><span class="p">,</span>
    <span class="s">&#39;django.middleware.cache.FetchFromCacheMiddleware&#39;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No, isso não é um erro de digitação: o middleware &quot;update&quot; deve aparecer primeiro na list,
e o middleware &quot;fetch&quot; por último. Os detalhes são um pouco obscuros, mas
veja <a class="reference internal" href="#ordem-das-middleware-classes">Ordem das MIDDLEWARE_CLASSES</a> abaixo se você quiser entender os detalhes.</p>
</div>
<p>Então, adicione as configurações necessárias ao seu arquivo de configurações do Django:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt> -- O número de segundos em que cada página deve permancecer
em cache.</li>
<li><tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_KEY_PREFIX</span></tt> -- Se o cache é compartilhado entre diversos
sites usando a mesma instalação do Django, configure isso para o nome do site,
ou alguma outra string única que identifique esse instância do Django, para previnir
colisões de cache. Use uma string vazia se você não se importa.</li>
</ul>
<p>O middleware de cache faz o cache de cada página que não tenha parâmetros de GET ou
POST. Opcionalmente, se a configuração <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_ANONYMOUS_ONLY</span></tt> for
<tt class="xref docutils literal"><span class="pre">True</span></tt>, somente requisições anônimas (i.e., aquelas feitas por usuários não autenticados)
serão cacheadas. Esse é um modo simples e eficiente para desabilita o cache para quaisquer
páginas específicas de usuários (incluindo a interface de administração do Django). Note que se você
usou o <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_ANONYMOUS_ONLY</span></tt>, você deve certificar-se de ter ativado o
<tt class="docutils literal"><span class="pre">AuthenticationMiddleware</span></tt>.</p>
<p>Adicionalmente, o middleware de cache adiciona alguma cabeçalhos em cada
<tt class="docutils literal"><span class="pre">HttpResponse</span></tt>:</p>
<ul class="simple">
<li>Configura o cabeçalho <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> para a data/hora atuais quando uma nova
versão da página (não cacheada) é resiquitada.</li>
<li>Configura o cabeçalho <tt class="docutils literal"><span class="pre">Expires</span></tt> para a hora atual mais o valor definido em
<tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt>.</li>
<li>Configura o cabeçalho <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> para dar um max age para a página -- novamente,
da configuração <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt>.</li>
</ul>
<p>Veja <a class="reference internal" href="http/middleware.html"><em>Middleware</em></a> para mais sobre middlewares.</p>
<p>Se uma visão configura o seu próprio tempo de expiração de cache (i.e. tem uma seção <tt class="docutils literal"><span class="pre">max-age</span></tt>
no seu cabeçalho <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>) então a página será mantida em cache até o tempo de
edxpiração, ao invés de <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt>. Usando os decoradores em
<tt class="docutils literal"><span class="pre">django.views.decorators.cache</span></tt> você pode facilmente configurar o tempo de expiração de
uma visão(usando o decorador <tt class="docutils literal"><span class="pre">cache_control</span></tt>) ou desabilitar o cache para uma visão (usando
o decorador <tt class="docutils literal"><span class="pre">never_cache</span></tt>). Veja a seção <a class="reference internal" href="#controlando-o-cache-usando-outros-cabecalhos">usando outros cabeçalhos</a> para mais
informações sobre esses decoradores.</p>
<div class="versionadded" id="i18n-cache-key">
<span class="title">New in Django 1.2:</span> <a class="reference internal" href="../releases/1.2.html"><em>Please, see the release notes</em></a></div>
<p>If <a class="reference internal" href="../ref/settings.html#std:setting-USE_I18N"><tt class="xref std std-setting docutils literal"><span class="pre">USE_I18N</span></tt></a> is set to <tt class="xref docutils literal"><span class="pre">True</span></tt> then the generated cache key will
include the name of the active <a class="reference internal" href="i18n/index.html#term-language-code"><em class="xref std std-term">language</em></a>.
This allows you to easily cache multilingual sites without having to create
the cache key yourself.</p>
<p>See <a class="reference internal" href="i18n/deployment.html"><em>Deployment of translations</em></a> for more on how Django discovers the active
language.</p>
</div>
<div class="section" id="s-o-cache-por-visao">
<span id="o-cache-por-visao"></span><h2>O cache por visão<a class="headerlink" href="#o-cache-por-visao" title="Permalink to this headline">¶</a></h2>
<p>Uma forma mais granular de usar o framework de cache é fazer o cache da saída
de visões individuais. <tt class="docutils literal"><span class="pre">django.views.decorators.cache</span></tt> define um decorador
<tt class="docutils literal"><span class="pre">cache_page</span></tt> que ierá automaticamente fazer o cache da resposta da visão para você.
É fácil de usar:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">cache_page</span>

<span class="nd">@cache_page</span><span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">cache_page</span></tt> recebe um único argumento: o timeout do cache, em segundos. No exemplo
acima, o resultado da visão <tt class="docutils literal"><span class="pre">slashdot_this()</span></tt> será mantido em cache por 15
minutos. (Note que escrevemos isso como <tt class="docutils literal"><span class="pre">60</span> <span class="pre">*</span> <span class="pre">15</span></tt> visando legibilidade.
<tt class="docutils literal"><span class="pre">60</span> <span class="pre">*</span> <span class="pre">15</span></tt> será avaliado para <tt class="docutils literal"><span class="pre">900</span></tt> -- isso é, 15 minutos multiplicados
por 60 segundos por minuto.)</p>
<p>O cache por visão, como o cache por site, é indexado de acordo com a URL. Se
múltiplas URLs apontam para a mesma visão, cada URL será cacheada separadamente.
Continuando o exemplo <tt class="docutils literal"><span class="pre">my_view</span></tt>, se o seu URLconf for semelhante a isso:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span>
    <span class="p">(</span><span class="s">r&#39;^foo/(\d{1,2})/$&#39;</span><span class="p">,</span> <span class="n">my_view</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>então requisições para <tt class="docutils literal"><span class="pre">/foo/1/</span></tt> e <tt class="docutils literal"><span class="pre">/foo/23/</span></tt> serão cacheadas separadamente, conforme
você pode esperar. Mas uma vez que uma URL em particular (ex: <tt class="docutils literal"><span class="pre">/foo/23/</span></tt>) tenha sido
requisitada, acessos subsequentes a essa URL usarão o cache.</p>
<p><tt class="docutils literal"><span class="pre">cache_page</span></tt> can also take an optional keyword argument, <tt class="docutils literal"><span class="pre">key_prefix</span></tt>, which
works in the same way as the <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_KEY_PREFIX</span></tt> setting for the
middleware.  It can be used like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@cache_page</span><span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">15</span><span class="p">,</span> <span class="n">key_prefix</span><span class="o">=</span><span class="s">&quot;site1&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="section" id="s-especificando-o-cache-por-visao-no-urlconf">
<span id="especificando-o-cache-por-visao-no-urlconf"></span><h3>Especificando o cache por visão no URLconf<a class="headerlink" href="#especificando-o-cache-por-visao-no-urlconf" title="Permalink to this headline">¶</a></h3>
<p>Os exemplos na seção anterior tem hard-coded o fato que a visão é
cacheada, porque <tt class="docutils literal"><span class="pre">cache_page</span></tt> altera a função <tt class="docutils literal"><span class="pre">my_view</span></tt> in place. Esse
método acopla suas visões ao sistema de cache, o que não é o ideal por diversas
razões. Por exemplo, você pode querer reusar as funções de visão em outro site,
sem cache, ou você pode querer distribuir suas visões para pessoas que podem
querer usá-las sem cache. A solução para esses problemas é
especificar o cache por visão no URLconf ao invés de configurá-lo nas
próprias funções.</p>
<p>Fazer isso é fácil: simplemente embrulhe a função de visão com <tt class="docutils literal"><span class="pre">cache_page</span></tt> quando você
se referir a ela no URLconf. Aqui está a nossa já conhecida URLconf:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span>
    <span class="p">(</span><span class="s">r&#39;^foo/(\d{1,2})/$&#39;</span><span class="p">,</span> <span class="n">my_view</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Aqui está a mesma coisa, com <tt class="docutils literal"><span class="pre">my_view</span></tt> embrulhada em <tt class="docutils literal"><span class="pre">cache_page</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">cache_page</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span>
    <span class="p">(</span><span class="s">r&#39;^foo/(\d{1,2})/$&#39;</span><span class="p">,</span> <span class="n">cache_page</span><span class="p">(</span><span class="n">my_view</span><span class="p">,</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Se você usar esse método, não se esqueça de importar <tt class="docutils literal"><span class="pre">cache_page</span></tt> dentro de seu
URLconf.</p>
</div>
</div>
<div class="section" id="s-cache-de-fragmento-de-template">
<span id="cache-de-fragmento-de-template"></span><h2>Cache de fragmento de template<a class="headerlink" href="#cache-de-fragmento-de-template" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<span class="title">New in Django 1.0:</span> <a class="reference internal" href="../releases/1.0.html"><em>Please, see the release notes</em></a></div>
<p>Se você quer ainda mais controle, você pode também fazer cache de fragmentos de
template usando a tag de template <tt class="docutils literal"><span class="pre">cache</span></tt>. Para permitir que seu template use essa tag, coloque
<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">cache</span> <span class="pre">%}</span></tt> perto do topo do seu template.</p>
<p>A tag de template <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">cache</span> <span class="pre">%}</span></tt> faz o cache do conteúdo do bloco por um certo período
de tempo. Recebe ao menos dois argumentos: o timeout do cache, em segundos,
e o nome que será dado ao cache de fragmento. Por exemplo:</p>
<div class="highlight-html+django"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">load</span> <span class="nv">cache</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">cache</span> <span class="m">500</span> <span class="nv">sidebar</span> <span class="cp">%}</span>
    .. sidebar ..
<span class="cp">{%</span> <span class="k">endcache</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>Algumas vezes você pode querer adicionar ao cache diversas cópias de um fragmento dependendo de
algum dado dinâmico que apareça dentro do fragmento. Por exemplo, você pode querer uma
cópia separada da barra lateral usada no exemplo anterior para cada usuário
do seu site. Faça isso passando argumentos adicionais a template tag <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">cache</span> <span class="pre">%}</span></tt>
que unicamente identifiquem esse cache de fragmento:</p>
<div class="highlight-html+django"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">load</span> <span class="nv">cache</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">cache</span> <span class="m">500</span> <span class="nv">sidebar</span> <span class="nv">request.user.username</span> <span class="cp">%}</span>
    .. sidebar for logged in user ..
<span class="cp">{%</span> <span class="k">endcache</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>É perfeitamente válido especificar mais de um argumento para identificar o fragmento.
Simplesmente passe tantos argumentos quanto você precisar para <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">cache</span> <span class="pre">%}</span></tt>.</p>
<p>If <a class="reference internal" href="../ref/settings.html#std:setting-USE_I18N"><tt class="xref std std-setting docutils literal"><span class="pre">USE_I18N</span></tt></a> is set to <tt class="xref docutils literal"><span class="pre">True</span></tt> the per-site middleware cache will
<a class="reference internal" href="#i18n-cache-key"><em>respect the active language</em></a>. For the <tt class="docutils literal"><span class="pre">cache</span></tt> template
tag you could use one of the
<a class="reference internal" href="i18n/internationalization.html#template-translation-vars"><em>translation-specific variables</em></a> available in
templates to archieve the same result:</p>
<div class="highlight-html+django"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">load</span> <span class="nv">i18n</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">load</span> <span class="nv">cache</span> <span class="cp">%}</span>

<span class="cp">{%</span> <span class="k">get_current_language</span> <span class="k">as</span> <span class="nv">LANGUAGE_CODE</span> <span class="cp">%}</span>

<span class="cp">{%</span> <span class="k">cache</span> <span class="m">600</span> <span class="nv">welcome</span> <span class="nv">LANGUAGE_CODE</span> <span class="cp">%}</span>
    <span class="cp">{%</span> <span class="k">trans</span> <span class="s2">&quot;Welcome to example.com&quot;</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">endcache</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>O timeout de cache pode ser uma variável de template, desde que a variável de template seja um
valor inteiro. Por exemplo, se a variável de template
<tt class="docutils literal"><span class="pre">my_timeout</span></tt> está configurada para o valor <tt class="docutils literal"><span class="pre">600</span></tt>, então os dois exemplos a seguir são
equivalentes:</p>
<div class="highlight-python"><pre>.. code-block:: html+django</pre>
</div>
<blockquote>
<div>{% cache 600 sidebar %} ... {% endcache %}
{% cache my_timeout sidebar %} ... {% endcache %}</div></blockquote>
<p>Essa característica é útil para evitar repetição em seus templates. Você pode configurar o
timeout em uma variável, em um lugar, e apenas reutilizar esse valor.</p>
</div>
<div class="section" id="s-a-api-de-baixo-nivel-do-cache">
<span id="a-api-de-baixo-nivel-do-cache"></span><h2>A API de baixo nível do cache<a class="headerlink" href="#a-api-de-baixo-nivel-do-cache" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, caching an entire rendered page doesn't gain you very much and is,
in fact, inconvenient overkill.</p>
<p>Talvez, por exemplo, o seu site inclua uma visão cujos resultados dependam de algumas
consultas intensivas ao banco de dados, cujos resultados mudem em diferentes intervalos.
Nesse caso, não seria ideal usar o cache completo de página que as estratégias de cache
por site ou por visão oferecem, porque você não quer fazer o cache do resultado
completo (já que alguns dados mudam frequentemente), mas você ainda gostaria
de manter em cache os resultados que mudam com menos frequência.</p>
<p>Para casos como esse, o Django expõe uma API simples de baixo nível de cache. Você pode usar
essa API para guardar objetos no cache com quaisquer níveis de granularidade que você quiser.
Você pode cacher quaisquer objetos Python que podem ser serializados com segurança: strings,
dicionários, listas ou objetos do modelo, e por aí vai. (A maioria dos objetos comum
do Python podem ser serializados através de pickle; veja a documentação do Python para mais informações
sobre o pickling.)</p>
<p>O módulo de cache, <tt class="docutils literal"><span class="pre">django.core.cache</span></tt> tem um objeto <tt class="docutils literal"><span class="pre">cache``que</span> <span class="pre">é</span>
<span class="pre">criado</span> <span class="pre">automaticamente</span> <span class="pre">a</span> <span class="pre">partir</span> <span class="pre">da</span> <span class="pre">configuração</span> <span class="pre">``CACHE_BACKEND</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="n">cache</span>
</pre></div>
</div>
<p>A interface básica é <tt class="docutils literal"><span class="pre">set(key,</span> <span class="pre">value,</span> <span class="pre">timeout_seconds)</span></tt> e <tt class="docutils literal"><span class="pre">get(key)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">,</span> <span class="s">&#39;hello, world!&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">)</span>
<span class="go">&#39;hello, world!&#39;</span>
</pre></div>
</div>
<p>O argumento <tt class="docutils literal"><span class="pre">timeout_seconds</span></tt> é opcional e o seu padrão é o mesmo do argumento <tt class="docutils literal"><span class="pre">timeout</span></tt>
na configuração <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> (explicada acima).</p>
<p>Se o objeto não existe no cache, <tt class="docutils literal"><span class="pre">cache.get()</span></tt> retorna <tt class="xref docutils literal"><span class="pre">None</span></tt>:</p>
<div class="highlight-python"><pre># Espere 30 segundos para 'my_key' expirar...

&gt;&gt;&gt; cache.get('my_key')
None</pre>
</div>
<p>We advise against storing the literal value <tt class="xref docutils literal"><span class="pre">None</span></tt> in the cache, because you
won't be able to distinguish between your stored <tt class="xref docutils literal"><span class="pre">None</span></tt> value and a cache
miss signified by a return value of <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">cache.get()</span></tt> pode ter um argumento <tt class="docutils literal"><span class="pre">padrão</span></tt>. Isso especifica qual valor retornar
se o objeto não existe no cache:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">,</span> <span class="s">&#39;has expired&#39;</span><span class="p">)</span>
<span class="go">&#39;has expired&#39;</span>
</pre></div>
</div>
<p>Para adicionar uma cache somente se ela ainda não existir, use o método <tt class="docutils literal"><span class="pre">add()</span></tt>.
Ele recebe os mesmos parâmetros que <tt class="docutils literal"><span class="pre">set()</span></tt>, mas não irá tentar atualizar o cache se a
chave especificada já estiver presente:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;add_key&#39;</span><span class="p">,</span> <span class="s">&#39;Initial value&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;add_key&#39;</span><span class="p">,</span> <span class="s">&#39;New value&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;add_key&#39;</span><span class="p">)</span>
<span class="go">&#39;Initial value&#39;</span>
</pre></div>
</div>
<p>Se você precisa saber se <tt class="docutils literal"><span class="pre">add()</span></tt> salvou um valor no cache, você pode
verificar o valor retornado. O retorno será <tt class="xref docutils literal"><span class="pre">True</span></tt> se o valor foi gravado,
e <tt class="xref docutils literal"><span class="pre">False</span></tt> se nada for gravado.</p>
<p>Existe também uma interface chamada <tt class="docutils literal"><span class="pre">get_many()</span></tt> que acessa o cache apenas uma vez.
<tt class="docutils literal"><span class="pre">get_many()</span></tt> retorna um dicionário com todas as chaves que você pediu
que estavam no cache e não estavem expiradas):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get_many</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">])</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
</pre></div>
</div>
<div class="versionadded">
<span class="title">New in Django 1.2:</span> <a class="reference internal" href="../releases/1.2.html"><em>Please, see the release notes</em></a></div>
<p>To set multiple values more efficiently, use <tt class="docutils literal"><span class="pre">set_many()</span></tt> to pass a dictionary
of key-value pairs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set_many</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get_many</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">])</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
</pre></div>
</div>
<p>Like <tt class="docutils literal"><span class="pre">cache.set()</span></tt>, <tt class="docutils literal"><span class="pre">set_many()</span></tt> takes an optional <tt class="docutils literal"><span class="pre">timeout</span></tt> parameter.</p>
<p>Você pode remover chaves diferentes com  <tt class="docutils literal"><span class="pre">delete()</span></tt>. Essa é uma forma
fácil de limpar o cache para um objeto em particular:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<span class="title">New in Django 1.2:</span> <a class="reference internal" href="../releases/1.2.html"><em>Please, see the release notes</em></a></div>
<p>If you want to clear a bunch of keys at once, <tt class="docutils literal"><span class="pre">delete_many()</span></tt> can take a list
of keys to be cleared:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">delete_many</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<span class="title">New in Django 1.2:</span> <a class="reference internal" href="../releases/1.2.html"><em>Please, see the release notes</em></a></div>
<p>Finally, if you want to delete all the keys in the cache, use
<tt class="docutils literal"><span class="pre">cache.clear()</span></tt>.  Be careful with this; <tt class="docutils literal"><span class="pre">clear()</span></tt> will remove <em>everything</em>
from the cache, not just the keys set by your application.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>Você pode também incrementar ou decrementar uma chave que já existe usando os métodos
<tt class="docutils literal"><span class="pre">incr()</span></tt> ou <tt class="docutils literal"><span class="pre">decr()</span></tt>, respectivamente. Por padrão, o valor existente em cache
será incrementado ou decrementado em 1. Outros valores para incremento/decremento
podem ser especificados fornecendo um argumento para a chamada increment/decrement. Um
ValueError será lançado se você tentar incrementar ou decrementar uma
chave de cache não existente.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;num&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s">&#39;num&#39;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">incr</span><span class="p">(</span><span class="s">&#39;num&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">decr</span><span class="p">(</span><span class="s">&#39;num&#39;</span><span class="p">)</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">decr</span><span class="p">(</span><span class="s">&#39;num&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">incr()</span></tt>/<tt class="docutils literal"><span class="pre">decr()</span></tt> não tem garantia de serem atômicos. Nos
backends que suportam incremento/decremento atômico (mais notavelmente, o
backend memcached), operações de incremento e decremento serão atômicas.
Porém, se o backend não provê nativamente uma operação de incremento/decremento,
ela será implementada usando uma operação obter/atualizar de dois passos.</p>
</div>
<div class="section" id="s-cache-key-prefixing">
<span id="s-id2"></span><span id="cache-key-prefixing"></span><span id="id2"></span><h3>Cache key prefixing<a class="headerlink" href="#cache-key-prefixing" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 1.3:</span> <a class="reference internal" href="../releases/1.3.html"><em>Please, see the release notes</em></a></div>
<p>If you are sharing a cache instance between servers, or between your
production and development environments, it's possible for data cached
by one server to be used by another server. If the format of cached
data is different between servers, this can lead to some very hard to
diagnose problems.</p>
<p>To prevent this, Django provides the ability to prefix all cache keys
used by a server. When a particular cache key is saved or retrieved,
Django will automatically prefix the cache key with the value of the
<tt class="xref std std-setting docutils literal"><span class="pre">KEY_PREFIX</span></tt> cache setting.</p>
<p>By ensuring each Django instance has a different
<tt class="xref std std-setting docutils literal"><span class="pre">KEY_PREFIX</span></tt>, you can ensure that there will be no
collisions in cache values.</p>
</div>
<div class="section" id="s-cache-versioning">
<span id="s-id3"></span><span id="cache-versioning"></span><span id="id3"></span><h3>Cache versioning<a class="headerlink" href="#cache-versioning" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 1.3:</span> <a class="reference internal" href="../releases/1.3.html"><em>Please, see the release notes</em></a></div>
<p>When you change running code that uses cached values, you may need to
purge any existing cached values. The easiest way to do this is to
flush the entire cache, but this can lead to the loss of cache values
that are still valid and useful.</p>
<p>Django provides a better way to target individual cache values.
Django's cache framework has a system-wide version identifier,
specified using the <tt class="xref std std-setting docutils literal"><span class="pre">VERSION</span></tt> cache setting.
The value of this setting is automatically combined with the cache
prefix and the user-provided cache key to obtain the final cache key.</p>
<p>By default, any key request will automatically include the site
default cache key version. However, the primitive cache functions all
include a <tt class="docutils literal"><span class="pre">version</span></tt> argument, so you can specify a particular cache
key version to set or get. For example:</p>
<div class="highlight-python"><pre># Set version 2 of a cache key
&gt;&gt;&gt; cache.set('my_key', 'hello world!', version=2)
# Get the default version (assuming version=1)
&gt;&gt;&gt; cache.get('my_key')
None
# Get version 2 of the same key
&gt;&gt;&gt; cache.get('my_key', version=2)
'hello world!'</pre>
</div>
<p>The version of a specific key can be incremented and decremented using
the <tt class="xref py py-func docutils literal"><span class="pre">incr_version()</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">decr_version()</span></tt> methods. This
enables specific keys to be bumped to a new version, leaving other
keys unaffected. Continuing our previous example:</p>
<div class="highlight-python"><pre># Increment the version of 'my_key'
&gt;&gt;&gt; cache.incr_version('my_key')
# The default version still isn't available
&gt;&gt;&gt; cache.get('my_key')
None
# Version 2 isn't available, either
&gt;&gt;&gt; cache.get('my_key', version=2)
None
# But version 3 *is* available
&gt;&gt;&gt; cache.get('my_key', version=3)
'hello world!'</pre>
</div>
</div>
<div class="section" id="s-cache-key-transformation">
<span id="s-id4"></span><span id="cache-key-transformation"></span><span id="id4"></span><h3>Cache key transformation<a class="headerlink" href="#cache-key-transformation" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 1.3:</span> <a class="reference internal" href="../releases/1.3.html"><em>Please, see the release notes</em></a></div>
<p>As described in the previous two sections, the cache key provided by a
user is not used verbatim -- it is combined with the cache prefix and
key version to provide a final cache key. By default, the three parts
are joined using colons to produce a final string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">make_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key_prefix</span><span class="p">,</span> <span class="n">version</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">key_prefix</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">version</span><span class="p">),</span> <span class="n">smart_str</span><span class="p">(</span><span class="n">key</span><span class="p">)])</span>
</pre></div>
</div>
<p>If you want to combine the parts in different ways, or apply other
processing to the final key (e.g., taking a hash digest of the key
parts), you can provide a custom key function.</p>
<p>The <tt class="xref std std-setting docutils literal"><span class="pre">KEY_FUNCTION</span></tt> cache setting
specifies a dotted-path to a function matching the prototype of
<tt class="xref py py-func docutils literal"><span class="pre">make_key()</span></tt> above. If provided, this custom key function will
be used instead of the default key combining function.</p>
</div>
<div class="section" id="s-cache-key-warnings">
<span id="cache-key-warnings"></span><h3>Cache key warnings<a class="headerlink" href="#cache-key-warnings" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">New in Django 1.3:</span> <a class="reference internal" href="../releases/1.3.html"><em>Please, see the release notes</em></a></div>
<p>Memcached, the most commonly-used production cache backend, does not allow
cache keys longer than 250 characters or containing whitespace or control
characters, and using such keys will cause an exception. To encourage
cache-portable code and minimize unpleasant surprises, the other built-in cache
backends issue a warning (<tt class="docutils literal"><span class="pre">django.core.cache.backends.base.CacheKeyWarning</span></tt>)
if a key is used that would cause an error on memcached.</p>
<p>If you are using a production backend that can accept a wider range of keys (a
custom backend, or one of the non-memcached built-in backends), and want to use
this wider range without warnings, you can silence <tt class="docutils literal"><span class="pre">CacheKeyWarning</span></tt> with
this code in the <tt class="docutils literal"><span class="pre">management</span></tt> module of one of your
<a class="reference internal" href="../ref/settings.html#std:setting-INSTALLED_APPS"><tt class="xref std std-setting docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="n">CacheKeyWarning</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">CacheKeyWarning</span><span class="p">)</span>
</pre></div>
</div>
<p>If you want to instead provide custom key validation logic for one of the
built-in backends, you can subclass it, override just the <tt class="docutils literal"><span class="pre">validate_key</span></tt>
method, and follow the instructions for <a class="reference internal" href="#usando-um-backend-de-cache-personalizado">usando um backend de cache personalizado</a>. For
instance, to do this for the <tt class="docutils literal"><span class="pre">locmem</span></tt> backend, put this code in a module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.core.cache.backends.locmem</span> <span class="kn">import</span> <span class="n">CacheClass</span> <span class="k">as</span> <span class="n">LocMemCacheClass</span>

<span class="k">class</span> <span class="nc">CacheClass</span><span class="p">(</span><span class="n">LocMemCacheClass</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">validate_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Custom validation, raising exceptions or warnings as needed.&quot;&quot;&quot;</span>
        <span class="c"># ...</span>
</pre></div>
</div>
<p>...and use the dotted Python path to this module as the scheme portion of your
<a class="reference internal" href="../ref/settings.html#std:setting-CACHE_BACKEND"><tt class="xref std std-setting docutils literal"><span class="pre">CACHE_BACKEND</span></tt></a>.</p>
</div>
</div>
<div class="section" id="s-caches-upstream">
<span id="caches-upstream"></span><h2>Caches Upstream<a class="headerlink" href="#caches-upstream" title="Permalink to this headline">¶</a></h2>
<p>Até agora, esse documento concentrou-se no cache de seus <em>próprios</em> dados. Mas outro tipo de
cache é relevante para o desenvolvimento Web: o cache executado por cache
&quot;upstream&quot;. Esses são sistemas que fazem o cache de páginas para usuários antes mesmo da
requisição chegar ao seu Web site.</p>
<p>Aqui estão algumns exemplos de cache upstream:</p>
<ul class="simple">
<li>Seu ISP pode fazer o cache de certas páginas, então se você requisitou uma página de
<a class="reference external" href="http://example.com/">http://example.com/</a>, seu ISP poderia enviar a página sem ter de acessar o
example.com diretamente. Os mantenedores de example.com não tem
conhecimento desse cache; O ISP fica entre example.com e o seu navegador
Web, lidando com todo o cache de forma transparente.</li>
<li>Seu Web site Django pode ficar atrás de um <em>proxy cache</em> como o proxy Squid
(<a class="reference external" href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>), que faz cache de páginas para performance. Nesse
caso, cada requisição seria tratada primeiramente pelo proxy
e seria passada para a sua aplicação somente se necessário.</li>
<li>Seu navegador web também faz cache. Se uma página envia os cabeçalhos
apropriados, seu navegador irá usar a cópia local (em cache) para requisições
subsequentes para essa página, sem nem mesmo contatar a página Web
novamente paraver se o conteúdo mudou.</li>
</ul>
<p>Caches upstream são um potencializador de eficiência interessante, mas há um perigo nisso:
muitos conteúdos de páginas web diferem baseados na autenticação e em diversas outras
variáveis, e sistemas de cache que servem páginas baseadas em URL cegamente
poderiam expor dados incorretos ou sensíveis para visitantes subsequentes a
essas páginas.</p>
<p>Por exemplo, digamos que você opere um serviço de webmail, e o conteúdo da página
&quot;inbox&quot; obviamente depende do usuário que está logado. Se um ISP cegamente
cacheia seu site, então o primeiro usuário que logou através desse ISP poderia ter
seu conteúdo da caixa de entrada exposto aos próximos visitantes do site. Isso
não é legal.</p>
<p>Felizmente, o HTTP fornece uma solução para esse problema: um número de cabeçalhos HTTP
existem para instruir os cache upstream a diferir seus conteúdos de cache dependendo de
certas variáveis definidas, e como dizer aos mecanismos de cache como
não cachear páginas particulares. Veremos alguns desses cabeçalhos na seção a seguir.</p>
</div>
<div class="section" id="s-usando-cabecalhos-vary">
<span id="s-using-vary-headers"></span><span id="usando-cabecalhos-vary"></span><span id="using-vary-headers"></span><h2>Usando cabeçalhos Vary<a class="headerlink" href="#usando-cabecalhos-vary" title="Permalink to this headline">¶</a></h2>
<p>O cabeçalho <tt class="docutils literal"><span class="pre">Vary</span></tt> define quais cabeçalhos de requisição
um mecanismo de cache deve levar em conta ao construir sua chave de cache.
Por exemplo, se o conteúdo do site de uma págfina web depende da preferência de
idioma do usuário, dizemos que a página &quot;varia no idioma.&quot;</p>
<div class="versionchanged">
<span class="title">Changed in Django 1.3:</span> In Django 1.3 the full request path -- including the query -- is used
to create the cache keys, instead of only the path component in Django 1.2.</div>
<p>Por padrão, o sistema de cache do DJango cria suas chaves de acesso usando o caminho
da requisição (ex: <tt class="docutils literal"><span class="pre">&quot;/stories/2005/jun/23/bank_robbed/&quot;</span></tt>). Isso significa que cada
requisição a essa URL irá usar a mesma versão do cache, não importando as diferentes
de agente de usuário, como cookies ou preferência de idioma.  Porém, se essa página
produz conteúdos diferentes baseados em alguma diferença de cabeçalhos de requisição -- como
um cookie, ou um idioma, ou um agente de usuário -- você irá precisar usar o cabeçalho <tt class="docutils literal"><span class="pre">Vary</span></tt>
para dizer aos mecanismos de cache que a saída da página depende dessas coisas.</p>
<p>Para fazer isso no Django, use o decorador de visão de conveniência <tt class="docutils literal"><span class="pre">vary_on_headers</span></tt>,
assim:</p>
<div class="highlight-python"><pre>from django.views.decorators.vary import vary_on_headers

@vary_on_headers('User-Agent')
def my_view(request):
    # ...</pre>
</div>
<p>Nesse caso, um mecanismo de cache (como o próprio middleware de cache do Django) irá
cachear uma versão diferente da página para cada agente de usuário único.</p>
<p>A vantagem de usar o decorador <tt class="docutils literal"><span class="pre">vary_on_headers</span></tt> ao invés de configurar o cabeçalho
<tt class="docutils literal"><span class="pre">Vary</span></tt> manualmente (usando algo como
<tt class="docutils literal"><span class="pre">response['Vary']</span> <span class="pre">=</span> <span class="pre">'user-agent'</span></tt>) é que o decorador <em>adiciona</em> algo ao cabeçalho <tt class="docutils literal"><span class="pre">Vary</span></tt>
(que pode já existir), ao invés de sobrescrevê-lo
e potencialmente apagar algo que já estava lá.</p>
<p>Você pode passar diversos cabeçalhos para <tt class="docutils literal"><span class="pre">vary_on_headers()</span></tt>:</p>
<div class="highlight-python"><pre>@vary_on_headers('User-Agent', 'Cookie')
def my_view(request):
    # ...</pre>
</div>
<p>Isso diz aos cache upstream  para variar em <em>ambos</em> os cabeçalhos, o que significa que cada combinação de
agente de usuário e cookie irá ter seu próprio valor de cache. Por exemplo, uma requisição com
o agente de usuário <tt class="docutils literal"><span class="pre">Mozilla</span></tt> e o valor de cookie <tt class="docutils literal"><span class="pre">foo=bar</span></tt> será considerado
diferente de uma requisição com um agente de usuário <tt class="docutils literal"><span class="pre">Mozilla</span></tt> e o valor de cookie
<tt class="docutils literal"><span class="pre">foo=ham</span></tt>.</p>
<p>Como a variação baseada em cookie é um caso comum, existe um decorador <tt class="docutils literal"><span class="pre">vary_on_cookie</span></tt>.
Essas duas views são equivalentes:</p>
<div class="highlight-python"><pre>@vary_on_cookie
def my_view(request):
    # ...

@vary_on_headers('Cookie')
def my_view(request):
    # ...</pre>
</div>
<p>Os cabeçalhos que você passa para <tt class="docutils literal"><span class="pre">vary_on_headers</span></tt> não são
sensíveis a caso. <tt class="docutils literal"><span class="pre">&quot;User-Agent&quot;</span></tt> é a mesma coisa que <tt class="docutils literal"><span class="pre">&quot;user-agent&quot;</span></tt>.</p>
<p>Você pode também usar uma função auxiliar, <tt class="docutils literal"><span class="pre">django.utils.cache.patch_vary_headers</span></tt>,
diretamente. Essa função configura ou adiciona ao <tt class="docutils literal"><span class="pre">cabeçalho</span> <span class="pre">Vary</span></tt>. Por exemplo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.utils.cache</span> <span class="kn">import</span> <span class="n">patch_vary_headers</span>

<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">render_to_response</span><span class="p">(</span><span class="s">&#39;template_name&#39;</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="n">patch_vary_headers</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Cookie&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">patch_vary_headers</span></tt> recebe uma instância de <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> como seu primeiro argumento
e uma lista/tupla de nomes de cabeçalho não sensíveis a caso como seu segundo argumento.</p>
<p>Para mais sobre os cabeçalhos Vary, veja a <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44">especificação oficial do Vary</a>.</p>
</div>
<div class="section" id="s-controlando-o-cache-usando-outros-cabecalhos">
<span id="controlando-o-cache-usando-outros-cabecalhos"></span><h2>Controlando o cache: Usando outros cabeçalhos<a class="headerlink" href="#controlando-o-cache-usando-outros-cabecalhos" title="Permalink to this headline">¶</a></h2>
<p>Outros problemas com o cache são a privacidade de dados e a questão de onde
os dados devem ser armazenados em uma cascada de caches.</p>
<p>Um usuário normalmente encontra dois tipos de cache: o do seu próprio navegador (um cache
privado) e o do seu provedor (um cache público). Um cache público é usado por
muitos usuários e controlado por mais alguém. Isso coloca problemas com
dados sensíveis--você não quer, por exemplo, que o número da sua conta bancária seja gravada em um
cache público. Assim, aplicações web precisam de uma forma de dizer aos caches quais dados são
privados e quais dados são públicos.</p>
<p>A solução é indicar que o cache de página seja &quot;particular&quot;. Para fazer isso no
Django, use o decorador de visão <tt class="docutils literal"><span class="pre">cache_control</span></tt>. Exemplo:</p>
<div class="highlight-python"><pre>from django.views.decorators.cache import cache_control

@cache_control(private=True)
def my_view(request):
    # ...</pre>
</div>
<p>Esse decorador cuida de enviar o cabeçalho HTTP apropriado nos bastidores.</p>
<p>Existem algumas outras formas de controlar os parâmetros de cache. Por exemplo, o HTTP
permite que aplicações façam o seguinte:</p>
<ul class="simple">
<li>Define o tempo máximo que uma página deva permanecer em cache.</li>
<li>Especifica se um cache deve sempre verificar por novas versões da página,
exibindo o conteúdo em cache apenas quando não houve mudanças. (Alguns caches
podem entregar conteúdo em cache mesmo se a página no servidor mudou -- simplesmente
porque a cópia do cache ainda não expirou.)</li>
</ul>
<p>No Django, use o decorador de visão <tt class="docutils literal"><span class="pre">cache_control</span></tt> para especificar esses parâmetros
de cache. Nesse exemplo, <tt class="docutils literal"><span class="pre">cache_control</span></tt> diz ao cache para revalidar o
cache em cada acesso e para guardar versões em cache em no máximo por 3600 segundos:</p>
<div class="highlight-python"><pre>from django.views.decorators.cache import cache_control

@cache_control(must_revalidate=True, max_age=3600)
def my_view(request):
    # ...</pre>
</div>
<p>Qualquer diretiva HTTP <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> é válida em <tt class="docutils literal"><span class="pre">cache_control()</span></tt>.
Aqui está uma lista completa:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">public=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">private=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">no_cache=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">no_transform=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">must_revalidate=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">proxy_revalidate=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">max_age=num_seconds</span></tt></li>
<li><tt class="docutils literal"><span class="pre">s_maxage=num_seconds</span></tt></li>
</ul>
<p>Para explicação das diretivas HTTP de Cache-Control, veja a <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">Especificação de Cache-Control</a>.</p>
<p>(Note que o middleware  de cache já configura o tempo máximo (max-age) do cache com
o valor da configuração <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SETTINGS</span></tt>. Se você usa um <tt class="docutils literal"><span class="pre">max_age</span></tt>
personalizado no decorador <tt class="docutils literal"><span class="pre">cache_control</span></tt>, o decorador terá precedência sobre a configuração,
e os valores do cabeçalho serão mesclados corretamente.)</p>
<p>Se você quer usar cabeçalhos para desabilitar todo o cache,
<tt class="docutils literal"><span class="pre">django.views.decorators.cache.never_cache</span></tt> é um decorador de visão que adiciona
cabeçalhos que garantem que a resposta não será posta em cache por navegadores ou outros caches.
Exemplo:</p>
<div class="highlight-python"><pre>from django.views.decorators.cache import never_cache

@never_cache
def myview(request):
    # ...</pre>
</div>
</div>
<div class="section" id="s-outras-otimizacoes">
<span id="outras-otimizacoes"></span><h2>Outras otimizações<a class="headerlink" href="#outras-otimizacoes" title="Permalink to this headline">¶</a></h2>
<p>O Django vem com alguns outros middlewares que podem ajudar a otimizar a performance
do seu aplicativo:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">django.middleware.http.ConditionalGetMiddleware</span></tt> adiciona suporte para
GET condicional em navegadores modernos, baseado nos cabeçalhos <tt class="docutils literal"><span class="pre">ETag</span></tt>
e <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">django.middleware.gzip.GZipMiddleware</span></tt> comprime conteúdo para todos os navegadores
modernos reduzindo o uso de banda e o tempo de transferência.</li>
</ul>
</div>
<div class="section" id="s-ordem-das-middleware-classes">
<span id="ordem-das-middleware-classes"></span><h2>Ordem das MIDDLEWARE_CLASSES<a class="headerlink" href="#ordem-das-middleware-classes" title="Permalink to this headline">¶</a></h2>
<p>Se você está usando o middleware de cache, é importador colocar cada parte dentro do lugar correto nas
configurações de <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt>. Isso porque o cabeçalho de cache
precisa saber por quais cabeçalhos ele irá variar o armazenamento de cache.
Middleware sempre adiciona algo ao cabeçalho <tt class="docutils literal"><span class="pre">Vary</span></tt> quando ele pode.</p>
<p><tt class="docutils literal"><span class="pre">UpdateCacheMiddleware</span></tt> executa durante a fase de resposta, onde os middlewares são
executados em ordem reversa, então um item no topo da lista sempre executa <em>por último</em> durante
a fase de resposta. Assim, você precisa garantir que <tt class="docutils literal"><span class="pre">UpdateCacheMiddleware</span></tt>
apareça <em>antes</em> de quaisquer outros middlewares que possam adicionar algo ao cabeçalho <tt class="docutils literal"><span class="pre">Vary</span></tt>.
Os seguintes módulos de middleware fazem isso so:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SessionMiddleware</span></tt> adiciona <tt class="docutils literal"><span class="pre">Cookie</span></tt></li>
<li><tt class="docutils literal"><span class="pre">GZipMiddleware</span></tt> adiciona <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt></li>
<li><tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt> adiciona <tt class="docutils literal"><span class="pre">Accept-Language</span></tt></li>
</ul>
<p><tt class="docutils literal"><span class="pre">FetchFromCacheMiddleware</span></tt>, por outro lado, executa durante a fase de requisição,
onde os middlewares são aplicados do primeiro ao último, então um item no topo da lista
execute <em>primeiro</em> durante a fase de requisição. O <tt class="docutils literal"><span class="pre">FetchFromCacheMiddleware</span></tt> também
precisa edxecutar depois de alguns outros middlewares atualizarem o cabeçalho <tt class="docutils literal"><span class="pre">Vary</span></tt>, assim
<tt class="docutils literal"><span class="pre">FetchFromCacheMiddleware</span></tt> deve ser configurado <em>após</em> qualquer item que faça isso.</p>
</div>
</div>


          </div>         
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">O framework de cache do Django</a><ul>
<li><a class="reference internal" href="#configurando-o-cache">Configurando o cache</a><ul>
<li><a class="reference internal" href="#memcached">Memcached</a></li>
<li><a class="reference internal" href="#cache-em-banco-de-dados">Cache em banco de dados</a><ul>
<li><a class="reference internal" href="#database-caching-and-multiple-databases">Database caching and multiple databases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cache-em-sistema-de-arquivos">Cache em sistema de arquivos</a></li>
<li><a class="reference internal" href="#cache-em-memoria-local">Cache em memória local</a></li>
<li><a class="reference internal" href="#cache-falso-para-desenvolvimento">Cache falso (para desenvolvimento)</a></li>
<li><a class="reference internal" href="#usando-um-backend-de-cache-personalizado">Usando um backend de cache personalizado</a></li>
<li><a class="reference internal" href="#argumentos-do-cache-backend">Argumentos do CACHE_BACKEND</a></li>
</ul>
</li>
<li><a class="reference internal" href="#o-cache-por-site">O cache por site</a></li>
<li><a class="reference internal" href="#o-cache-por-visao">O cache por visão</a><ul>
<li><a class="reference internal" href="#especificando-o-cache-por-visao-no-urlconf">Especificando o cache por visão no URLconf</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cache-de-fragmento-de-template">Cache de fragmento de template</a></li>
<li><a class="reference internal" href="#a-api-de-baixo-nivel-do-cache">A API de baixo nível do cache</a><ul>
<li><a class="reference internal" href="#cache-key-prefixing">Cache key prefixing</a></li>
<li><a class="reference internal" href="#cache-versioning">Cache versioning</a></li>
<li><a class="reference internal" href="#cache-key-transformation">Cache key transformation</a></li>
<li><a class="reference internal" href="#cache-key-warnings">Cache key warnings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#caches-upstream">Caches Upstream</a></li>
<li><a class="reference internal" href="#usando-cabecalhos-vary">Usando cabeçalhos Vary</a></li>
<li><a class="reference internal" href="#controlando-o-cache-usando-outros-cabecalhos">Controlando o cache: Usando outros cabeçalhos</a></li>
<li><a class="reference internal" href="#outras-otimizacoes">Outras otimizações</a></li>
<li><a class="reference internal" href="#ordem-das-middleware-classes">Ordem das MIDDLEWARE_CLASSES</a></li>
</ul>
</li>
</ul>

  <h3>Browse</h3>
  <ul>
    
      <li>Prev: <a href="auth.html">Autenticação de Usuário no Django</a></li>
    
    
      <li>Next: <a href="conditional-view-processing.html">Conditional View Processing</a></li>
    
  </ul>
  <h3>Você está aqui:</h3>
  <ul>
      <li>
        <a href="../index.html">Django v1.3.1 documentation</a>
        
          <ul><li><a href="index.html">Usando o Django</a>
        
        <ul><li>O framework de cache do Django</li></ul>
        </li></ul>
      </li>
  </ul>  

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/topics/cache.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Última atualização:</h3>
              <p class="topless">Dec 06, 2011</p>
          </div> 
        
      
    </div>
    
    <div id="ft">
      <div class="nav">
    &laquo; <a href="auth.html" title="Autenticação de Usuário no Django">previous</a> 
     |
    <a href="index.html" title="Usando o Django" accesskey="U">up</a>
   |
    <a href="conditional-view-processing.html" title="Conditional View Processing">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>